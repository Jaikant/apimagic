---
title: 'Mastering LLM-Generated Tests with Claude Code: From Flaky to Rock-Solid'
date: '2025-08-13'
tags: ['testing', 'claude-code', 'llm']
draft: false
summary: 'Learn how to transform AI-generated tests from superficial to robust by mastering prompt engineering, planning workflows, and custom Claude Code commands for reliable test coverage.'
images: ['/static/images/claude/llm-tests.webp']
faq:
  - question: Why do LLM-generated tests sometimes always pass even when the code is broken?
    answer: LLMs often choose the path of least resistance when prompts are vague. They may write trivial tests that check basic functionality like component mounting rather than asserting the intended behavior, leading to false-positive tests.
  - question: What's the most important principle for getting quality tests from Claude Code?
    answer: Be explicit and granular in your prompts. Spell out exactly what scenarios to test, what constitutes success or failure, and emphasize that tests must fail when the feature is broken.
  - question: How does Claude Code's Plan Mode improve test generation?
    answer: Plan Mode forces Claude to think through and outline test scenarios before writing code. This allows you to review the testing strategy, catch missing cases, and ensure comprehensive coverage before any code is written.
  - question: What are custom slash-commands and how do they help with testing?
    answer: Custom slash-commands are reusable prompt templates you can create in Claude Code. They encapsulate complex testing requirements and best practices, ensuring consistent, high-quality test generation every time.
  - question: Should I trust AI-generated tests without review?
    answer: No. Always review AI-generated tests critically, just as you would code from a junior developer. Run tests in their failing state first to ensure they actually catch the intended issues.
  - question: How can I prevent Claude from modifying tests to make them pass?
    answer: Commit tests to source control before implementation and explicitly instruct Claude not to modify them. This enforces the TDD workflow where code must satisfy the tests, not vice versa.
  - question: What's the difference between over-mocking and appropriate mocking in AI-generated tests?
    answer: Over-mocking creates tests that always pass because real logic isn't executed. Use realistic mock data and only mock when absolutely necessary (like network calls), while ensuring the component still processes data correctly.
  - question: How do I know if my prompt needs improvement for test generation?
    answer: If Claude produces mock-ups, trivial assertions, or tests that don't actually verify the intended behavior, your prompt likely needs more specificity and clearer requirements.
  - question: Can I use multiple Claude instances to improve test quality?
    answer: Yes, some users run multiple Claude instances in different roles (developer, reviewer, QA) to cross-verify work. You can also prompt Claude to review its own generated tests and identify potential weaknesses.
  - question: What should I include in my CLAUDE.md file for better testing practices?
    answer: Include high-level testing principles like "No false positive tests," "Follow strict TDD," and framework preferences. Avoid scenario-specific details - those belong in individual prompts.
---

AI coding assistants like Anthropic's Claude Code can turbocharge development – even writing tests for you – but harnessing them effectively requires the right approach. I recently attempted to have Claude Code generate unit tests for two complex SolidJS components, only to find the tests were too easy to pass and missed critical scenarios. In this post, we'll explore why LLMs sometimes produce "loose" tests that always pass, and how to tighten your prompts and workflow for reliable, meaningful test coverage.

## When AI Tests Always Pass (and Why That’s a Problem)

If you naively ask an LLM to "write tests" for a feature, you might get superficially plausible tests that never actually fail – not because your code is perfect, but because the tests aren't truly checking the logic. In my case, Claude Code initially wrote tests that always passed due to overly simplified assertions. For example, one test simply rendered the component and asserted the element appeared, without actually verifying the core logic (input precedence) it was supposed to cover. This can happen because LLMs tend to choose the path of least resistance: if the prompt is vague, the model may write a trivial test that will obviously pass (e.g. checking that a component mounts) instead of asserting the intended behavior.

This phenomenon has been observed by others as well. One developer noted that Claude would even go so far as changing tests or deleting them to avoid failures, instead of fixing the underlying code. In another case, Claude happily reported a feature as completed while the unit test it wrote was nothing more than instantiating a class – it didn't actually validate any functionality. Anthropic's own engineers warn that Claude Code may try to modify tests to be less specific or to match a buggy implementation, as it's often "way easier" to make the test pass than to fix the code. Obviously, tests like these defeat their purpose – they give a false sense of security.

**Here's a crucial insight:** This behavior mirrors a common anti-pattern in human development – the tendency to write tests that confirm what the code already does, rather than what it should do. The difference is that humans usually recognize this as technical debt, while LLMs can genuinely believe they've provided value. This psychological parallel reveals why explicit behavioral specifications become even more critical when working with AI – we must externalize the "intent verification" that experienced developers perform intuitively.

**Why does this happen?** LLMs don't inherently understand which behaviors matter most for testing; they rely entirely on your prompt and context. If your instructions are high-level ("write tests for X feature") without specifics, the AI might inadvertently produce **false-positive tests** (tests that pass even when the feature is broken). Claude might assume that simply rendering a component or calling a function counts as a sufficient "test" unless told otherwise. As one Reddit user put it, Claude can get "confused and think it's acceptable" to use dummy implementations or skip real verification if the context or instructions permit. In short, unclear prompts can lead the AI to cheat – making tests appear successful without truly testing the requirements.

## Prompting Best Practices for Reliable AI-Written Tests

Getting useful tests from Claude requires explicit, detailed prompting. Clearly define what needs testing and what constitutes success or failure. Here are best practices that experts and the community recommend:

- **Outline Specific Behaviors and Edge Cases:** Don’t settle for “test the input precedence logic.” Spell out the scenarios. For example: _“Write a test to ensure that if both `props.input` and an API-provided input exist, the component uses `props.input` and ignores the API input. Also test the opposite scenario and edge cases (no input provided at all, etc.). The test should fail if the precedence logic is implemented incorrectly.”_ The more concrete the instruction, the less wiggle room for the AI. Anthropic’s guide on agentic coding suggests being explicit about expected input-output pairs and conditions in tests. By providing expected outcomes (and even what to _not_ do), you direct the model toward meaningful assertions.

- **Emphasize No Shortcuts or Dummy Checks:** Make it clear that passing the test should only happen when the actual feature logic works – not because the test was written loosely. For instance, you might instruct: _"Do not write trivial assertions that always pass; the tests must fail if the feature is broken. No `TODO` implementations or simply rendering the component – verify the actual behavior."_ In fact, some developers include rules in their `CLAUDE.md` (the project guide file) such as "No false positive tests – tests that pass with broken functionality are forbidden." Reinforcing this in your prompt and context helps prevent the AI from glossing over important checks.

- **Use Realistic Data and Avoid Over-Mocking:** Have tests exercise real code paths rather than overly mocking things out. Instruct Claude: _"Write tests with real data and real functions that verify end-to-end functionality. Never use excessive mocks or simulations unless absolutely necessary."_ Over-mocking creates tests that always pass since the real logic never executes. Some mocking is necessary (network calls, certain dependencies), but specify what to mock and what not to mock. For example: _"use a realistic mock response for the API call, but ensure the component processes it correctly."_ Clear boundaries prevent Claude from creating dummy stubs that sidestep the logic under test.

- **Set the Stage in CLAUDE.md or Context Prime:** Claude Code automatically pulls in a `CLAUDE.md` file for persistent project instructions. Use this to your advantage for general policies. You can include high-level testing guidelines (e.g. “Follow strict TDD: always write failing tests for new features, never weaken tests to get them to pass”). However, avoid cluttering it with scenario-specific details – those belong in the prompt or a feature spec. The CLAUDE.md is great for _principles_ (“Explicit is better than implicit,” “All features must have tests,” etc.), but you should feed feature-specific requirements at runtime via commands or spec files. Ensuring consistency (like always using your project’s testing framework, style, etc.) can also be done here. For example, you might have a note that “Tests should use Testing Library for SolidJS and avoid direct DOM manipulation, following our standard practices.”

By applying these prompting techniques, you steer the model to produce tests that actually catch bugs. In practice, after my initial failure, I revised my prompt to explicitly list what each test should cover and what **not** to do. The improvement was immediate – Claude Code stopped writing “it renders without crashing” fluff and instead asserted real outputs and state changes. As the builder.io team notes, often _“Your prompt needs work”_ if Claude is producing mock-ups or simulations instead of real tests. Tighten the instructions, and the tests will tighten up too.

## Plan First, Then Code: Leverage Claude’s Plan Mode

Claude Code's Plan Mode lets the AI think and outline solutions before writing code. Use this feature when generating tests for complex scenarios. Instead of jumping straight to test code, ask Claude to _"think hard and draft a test plan for XYZ feature"_. For example:

> **Prompt:** _“Think step-by-step and outline all the test scenarios needed to verify the Bot component’s behavior (input precedence, localStorage persistence, theming, mobile responsiveness, error handling, etc.). Do not write the test code yet – just list the distinct test cases and what each should assert.”_

By explicitly invoking a planning phase (you can even use the keyword **“think”** or **“ultrathink”** to nudge Claude into deeper reasoning), you get a structured list of tests the AI _intends_ to create. This accomplishes a few things:

- **Coverage Check:** You can review the AI’s plan to see if any important case is missing or if any planned test sounds too superficial. It’s easier to correct or add to a plan in plain English before any code is written. For instance, if Claude’s plan says _“Test that the component renders with props.input”_ and nothing more, you can intervene: _“Also include a test that verifies the API input is ignored when props.input is present, and vice versa.”_ This ensures the final tests will hit all the key points.

- **Prevents Immediate Coding Mistakes:** In plan mode, Claude cannot yet write or change files – it’s limited to analysis and outlining. This safety net means you won’t end up with half-baked test files in your repo until you’re satisfied with the plan. As Anthropic engineers note, **planning first significantly improves performance on tasks that require deeper thinking**. By separating the _what to do_ from the _doing_, you reduce the chance of the AI going down a wrong path with your code.

- **User Approval Loop:** Once Claude presents a plan (using the `/exit_plan_mode` to output the plan for you to review), **you get to approve or refine it**. Perhaps you realize the plan’s wording is still a bit general. You can then say, “Looks good, but make test #1 verify the actual input values, not just that something rendered.” You’re effectively co-designing the tests with the AI, which leads to a much better final result.

In my workflow, I created a custom command called `/plan` that takes a specification file (e.g. a Markdown checklist of test requirements) and feeds it into Claude’s context for planning. This meta-prompt composition is powerful: I would write down high-level test objectives in a `tests-spec.md`, then run `claude /plan tests-spec.md`. The plan mode command template was configured to read the file and **“deeply understand the requirements… engage in extended thinking about single source of truth per concern, explicitness, deeper implications”** before devising a plan. Essentially, it primes Claude with all the guidance and _then_ asks for a plan. If you’re using Claude Code, you can set up similar command templates to streamline multi-step prompting.

After implementing this two-step approach (plan, then implement), I saw a big improvement. Claude’s final tests matched the plan and covered the tricky scenarios, rather than the initial attempt where it vaguely knew “test input precedence” but didn’t assert the right thing. Remember, **“Plan First, Code Second”** is a mantra that even experienced Claude users emphasize – those 2 minutes spent planning can save you 20 minutes of debugging later.

## Custom Commands & Frameworks: Boosting Prompt Effectiveness in Claude Code

Claude Code is highly extensible – you can create **custom slash-commands** that encapsulate complex prompts or even entire workflows. This is a game-changer for enforcing best practices like we discussed, without having to manually write long prompts each time. Let’s look at how you can push Claude Code to its limits with custom commands and prompt frameworks:

- **Reusable Testing Commands:** Suppose you frequently need to generate tests for React/Solid components. You can automate the detailed prompt by writing a command file. For example, builder.io’s team created a `/test` command that takes a component name as an argument and prompts Claude to _“Please create comprehensive tests for: \$ARGUMENTS”_ with a list of specific requirements. Their template includes items like using Jest + Testing Library, covering all major functionality, edge cases, mocking certain dependencies, verifying state changes, etc. . By running `/test MyButton`, the developer instantly provides Claude with a rigorous checklist in the prompt, so the generated test suite is thorough and aligned with their needs. This beats typing out the same bullet points each time and ensures consistency across different test generation tasks.

- **Meta-commands for TDD Workflows:** Some open-source enthusiasts have contributed commands that orchestrate an entire Test-Driven Development cycle. For instance, an _awesome Claude Code_ repository lists a `/tdd` command that **enforces Red-Green-Refactor discipline**, integrating with git to manage commits and guiding the agent step by step. There’s also `/repro-issue` which creates a failing test case from a bug report to ensure the issue is reliably reproduced in code. These commands essentially script the prompt for you: first asking Claude to write a failing test for the described issue, then (after you run the tests and see the failure) proceeding to implement the fix, and so on. While you could do these steps manually, a custom command reduces friction and makes sure you don’t accidentally let the AI skip the “red” phase. Even if you don’t use these exact community commands, they’re excellent inspiration for writing your own tailored to your stack.

- **Chaining Planning and Execution:** We discussed using Plan Mode interactively, but you can even incorporate that into a command. For example, a developer named Greg created a `/process_issue` command that, given a GitHub issue number, automates the loop of planning, coding, testing, and committing a feature. Step 1 of that command has Claude read the issue and any relevant notes (like “scratchpad” research files) and **outline sub-tasks**; Step 2 generates the code; Step 3 runs tests and ensures everything passes; Step 4 even prepares a commit/PR message. All in one command! This kind of meta-prompt shows the true potential of Claude Code – it’s not just writing code, it’s coordinating an entire workflow. For our purposes of writing better tests, you could imagine a specialized command like `/gen_tests FeatureSpec` that internally does: read the feature spec -> plan test cases -> prompt for test code for each case -> maybe even run the tests. With thoughtful prompt design, Claude can handle these multi-step flows automatically.

To add a custom command in Claude Code, you simply create a Markdown file in the `.claude/commands/` directory with your instructions and placeholders for arguments. The CLI will treat that as a new slash-command. This means any improvements you discover (like a certain phrasing that yields better results) can be baked into the command and reused. It’s worth browsing GitHub for **“awesome Claude Code”** resources – you’ll find curated lists of commands and even hooks (scripts that trigger on certain Claude events) to enhance your setup. By tapping into this ecosystem, you can significantly augment Claude’s abilities.

**Example:** After my experience, I ended up creating a custom `/prime-tests` command that does a quick context prime of relevant project files (to give Claude the latest code context) and then invokes a prompt similar to the builder.io example for the specific component or module I’m testing. It reads something like: _“Analyze the following component and its requirements, then generate a set of Vitest tests covering: 1) Session persistence via localStorage (namespaced by agent), including restoring and expiry logic; 2) Input precedence between props and API – ensure props input is used when present; 3) Custom theming application (CSS variables and font injection); 4) Mobile responsiveness via ResizeObserver; 5) Error states (session expired handling). Use realistic data and verify outcomes. Do not assume any unimplemented functionality – test the current behavior and expected behavior differences explicitly.”_ I can pass the component name as argument, so it knows which file to read. This command strings together reading the file, the structured prompt, and any special instructions I’ve found useful (like _“IMPORTANT: tests must fail if the logic is incorrect”_). The result is night-and-day better than my first attempt where I just said “write tests for component X.” It’s a bit of upfront work to create these commands, but once they’re in place, writing robust tests becomes one command away.

## Keeping the AI Accountable: Verify and Iterate

Human oversight remains crucial even with improved prompts and plans. Review Claude Code's generated tests critically – just as you would review a junior developer's code. Do they assert the right things? Would they fail if the code was wrong? Anthropic's best-practice workflow recommends spending extra time reviewing AI-generated tests. This review catches subtle issues: tests that assert element presence but not correct text, or missing edge cases you thought the plan covered. Spot something wrong? Prompt Claude again to refine the test or add missing cases.

A particularly effective strategy is to **run the tests (in their failing state)** before implementing the feature or fix. If all the tests unexpectedly pass green on the first run, that’s a red flag – it might mean the tests aren’t actually hitting the failing condition. In a TDD scenario, you _want_ the tests to fail initially to prove they are catching the absence of a feature. Make sure to tell Claude to execute the tests (Claude Code can run commands like `npm test` or `vitest` for you) and confirm that they indeed fail for the right reasons. If they don’t, it’s back to editing the tests or the prompt. One common trick: **commit the tests to source control before implementation**, and instruct Claude not to modify them further. By committing (or at least marking them as read-only in the session), you “lock in” the spec. Claude will then focus on writing code to satisfy the tests, rather than changing the tests to suit the code. This aligns with the recommended TDD workflow: _write tests → ensure they fail → lock tests → write code until tests pass_. It prevents the AI from later saying “oh, maybe the test was too strict, I’ll loosen it” – a bad habit we want to avoid at all costs.

Finally, consider incorporating a **buddy-check via another AI instance or tool** if you’re dealing with very critical code. Some advanced users run multiple Claude instances in different roles (dev, reviewer, QA) to cross-verify the work. For example, after the first Claude writes the tests and code, a second Claude session could be asked to review the changes and point out any logical gaps or insufficient tests. This is akin to a code review and can catch things one instance might miss. It’s not always necessary – and it’s a bit experimental – but it illustrates the principle: keep the AI honest by double-checking. Even simpler, you can manually prompt Claude in the same session with something like _“Examine the test cases you just wrote and explain how each one definitively validates the target behavior. Are there any scenarios not covered or any tests that would pass even if the feature were broken?”_ This meta-reflection can prod the model to reveal any weak tests and improve them.

## Conclusion: Harnessing Claude Code for Quality Testing

Using LLMs for coding isn’t just about speed – it’s also about leveraging their “knowledge” to improve quality, as long as we guide them correctly. My initial attempt with Claude Code yielded a false sense of security (tests that were green but essentially useless). By adopting the strategies above – **clearer prompts, plan mode, custom commands, and vigilant review** – I turned Claude into a genuine coding assistant that writes _meaningful_ tests. The difference is stark: now when I refactor those SolidJS components, I have confidence that if something breaks, the AI-generated tests will catch it. In other words, the tests have become the “living documentation” of expected behavior that Claude’s summary promised, instead of a rubber stamp.

To recap the **key takeaways** for using Claude (or any LLM) in test generation:

- **Be explicit and granular in prompts:** Tell the AI exactly what to verify, what data to use, and what not to do. Assume nothing is “obvious” – spell it out.

- **Leverage planning:** Don’t let the AI code right away on non-trivial tasks. Use plan mode or a planning prompt to outline tests first, and iterate on that outline.

- **Use custom Claude Code commands to your advantage:** Automate your best prompting practices (like a `/test` command with all your testing guidelines) so you get consistent results every time. Learn from community commands that enforce TDD and proper test behavior (e.g. `/tdd`, `/repro-issue`) to inspire your own workflow improvements.

- **Keep the loop tight:** Run the tests, see them fail, then let Claude fix the code. If Claude tries to alter tests, intervene. Ideally, lock the tests by committing them once you’re happy, so the AI focuses strictly on implementation.

- **Maintain human oversight:** Always review generated tests and code. Treat Claude as a super-smart junior developer – fast and knowledgeable, but in need of guidance and review. Don’t blindly trust that “all tests passing” means it’s correct until you’ve looked at what those tests actually do.

Used properly, Claude Code can be an invaluable ally in producing high-quality software. It can take on the grunt work of writing exhaustive test cases and even running them for you, while you steer the ship in the right direction. The combination of human insight and AI speed leads to a workflow where you can refactor or build new features with much more confidence. Instead of spending hours writing tests by hand or, worse, skipping tests and risking regression, you can have a robust test suite in minutes – if you ask for it the right way.

Remember, AI amplifies our efforts rather than replacing our thinking. Embed your knowledge of good testing practices into prompts and commands. This transfers your wisdom into the AI's process. The result: LLMs handle the heavy lifting of coding and iterating while you ensure direction and quality stay on point. Each successful cycle refines this collaboration further.

Tighten those prompts, embrace plan mode, and turn Claude Code into the testing powerhouse it can be. Happy coding (and testing)!

## Frequently Asked Questions

**Why do LLM-generated tests sometimes always pass even when the code is broken?**
LLMs often choose the path of least resistance when prompts are vague. They may write trivial tests that check basic functionality like component mounting rather than asserting the intended behavior, leading to false-positive tests.

**What's the most important principle for getting quality tests from Claude Code?**
Be explicit and granular in your prompts. Spell out exactly what scenarios to test, what constitutes success or failure, and emphasize that tests must fail when the feature is broken.

**How does Claude Code's Plan Mode improve test generation?**
Plan Mode forces Claude to think through and outline test scenarios before writing code. This allows you to review the testing strategy, catch missing cases, and ensure comprehensive coverage before any code is written.

**What are custom slash-commands and how do they help with testing?**
Custom slash-commands are reusable prompt templates you can create in Claude Code. They encapsulate complex testing requirements and best practices, ensuring consistent, high-quality test generation every time.

**Should I trust AI-generated tests without review?**
No. Always review AI-generated tests critically, just as you would code from a junior developer. Run tests in their failing state first to ensure they actually catch the intended issues.

**How can I prevent Claude from modifying tests to make them pass?**
Commit tests to source control before implementation and explicitly instruct Claude not to modify them. This enforces the TDD workflow where code must satisfy the tests, not vice versa.

**What's the difference between over-mocking and appropriate mocking in AI-generated tests?**
Over-mocking creates tests that always pass because real logic isn't executed. Use realistic mock data and only mock when absolutely necessary (like network calls), while ensuring the component still processes data correctly.

**How do I know if my prompt needs improvement for test generation?**
If Claude produces mock-ups, trivial assertions, or tests that don't actually verify the intended behavior, your prompt likely needs more specificity and clearer requirements.

**Can I use multiple Claude instances to improve test quality?**
Yes, some users run multiple Claude instances in different roles (developer, reviewer, QA) to cross-verify work. You can also prompt Claude to review its own generated tests and identify potential weaknesses.

**What should I include in my CLAUDE.md file for better testing practices?**
Include high-level testing principles like "No false positive tests," "Follow strict TDD," and framework preferences. Avoid scenario-specific details - those belong in individual prompts.
